<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Prototype</title>
      <link href="/2019/09/03/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/09/03/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-原型"><a href="#1-原型" class="headerlink" title="1.原型"></a>1.原型</h2><h3 id="1-原型是什么？"><a href="#1-原型是什么？" class="headerlink" title="1.原型是什么？"></a>1.原型是什么？</h3><p>1.函数的prototype属性</p><ul><li>每个函数都有一个prototype属性, 它默认是一个对象(即称为: 原型对象)</li><li>原型对象中默认有两个属性<ul><li>constructor, 它指向函数对象</li><li><strong>proto</strong>，隐式原型属性 , 它的值为Object.prototype </li></ul></li></ul><p>2.原型属性在哪里？</p><ul><li>prototype : 所有的函数都有prototype属性，这个属性指向一个对象，对象称之为原型对象</li><li>constructor  指向函数本身</li><li><strong>proto</strong>    指Object.prototype</li><li><strong>proto</strong> : 所有实例对象都会有<strong>proto</strong></li></ul><h3 id="2-显式原型与隐式原型"><a href="#2-显式原型与隐式原型" class="headerlink" title="2.显式原型与隐式原型"></a>2.显式原型与隐式原型</h3><ol><li>每个函数function都有一个prototype，即显式原型</li><li>每个实例对象都有一个<strong>proto</strong>，可称为隐式原型</li><li>对象的隐式原型的值为其对应构造函数的显式原型的值</li></ol><h3 id="3-隐式原型链"><a href="#3-隐式原型链" class="headerlink" title="3.隐式原型链"></a>3.隐式原型链</h3><ul><li>先找自身，找到返回，如果没又，沿着隐式原型（proto）找到构造函数的显示原型上，如果还没有，就去Object的原型上找，如果还找不到，返回undefined</li></ul><h3 id="4-对象属性的读取与设置"><a href="#4-对象属性的读取与设置" class="headerlink" title="4.对象属性的读取与设置"></a>4.对象属性的读取与设置</h3><ul><li>读取对象的属性值时: 会自动到原型链中查找</li><li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li><li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li></ul><h3 id="5-原型的作用"><a href="#5-原型的作用" class="headerlink" title="5.原型的作用"></a>5.原型的作用</h3><ul><li>实现继承：实例对象继承构造函数的属性或者方法</li></ul><h3 id="6-instance-of"><a href="#6-instance-of" class="headerlink" title="6.instance of"></a>6.instance of</h3><ul><li>A(对象) instance of B(函数)<ul><li>判断A对象是否是B函数的实例</li><li>如果B函数的显式原型在A实例对象的隐式原型节点上，那就返回true，否则返回false;<ul><li>Object instanceof Function   //true</li><li>Object instanceof Object     //true</li><li>Function instanceof Object   //true</li><li>Function instanceof Function //true</li><li>Object instanceof Fn         //false</li></ul></li></ul></li></ul><h3 id="7-注意"><a href="#7-注意" class="headerlink" title="7.注意"></a>7.注意</h3><h4 id="①-Function是通过new自己产生的实例"><a href="#①-Function是通过new自己产生的实例" class="headerlink" title="① Function是通过new自己产生的实例"></a>① Function是通过new自己产生的实例</h4><h4 id="②-for-in-枚举-除了枚举自身对象上的属性还会沿着原型链寻找属性"><a href="#②-for-in-枚举-除了枚举自身对象上的属性还会沿着原型链寻找属性" class="headerlink" title="② for in(枚举)除了枚举自身对象上的属性还会沿着原型链寻找属性"></a>② for in(枚举)除了枚举自身对象上的属性还会沿着原型链寻找属性</h4><h4 id="③-Function是通过new自己产生的实例"><a href="#③-Function是通过new自己产生的实例" class="headerlink" title="③ Function是通过new自己产生的实例"></a>③ Function是通过new自己产生的实例</h4><h4 id="④-Object上还存在hasOwnProperty-判断属性是否是自己的属性-、toString-返回’-object-Object-’-以及value-of等方法"><a href="#④-Object上还存在hasOwnProperty-判断属性是否是自己的属性-、toString-返回’-object-Object-’-以及value-of等方法" class="headerlink" title="④ Object上还存在hasOwnProperty(判断属性是否是自己的属性)、toString(返回’[object Object]’)以及value of等方法"></a>④ Object上还存在hasOwnProperty(判断属性是否是自己的属性)、toString(返回’[object Object]’)以及value of等方法</h4><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h3 id="测试题1"><a href="#测试题1" class="headerlink" title="测试题1"></a>测试题1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line">      var A = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">A.prototype.n = 1</span><br><span class="line"></span><br><span class="line">var b = new A()</span><br><span class="line"></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">  n: 2,</span><br><span class="line">  m: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c = new A()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(b.n, b.m, c.n, c.m)  // 1 undefined 2 3</span><br></pre></td></tr></table></figure><h3 id="测试题2"><a href="#测试题2" class="headerlink" title="测试题2"></a>测试题2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">var F = function()&#123;&#125;;</span><br><span class="line"> Object.prototype.a = function()&#123;</span><br><span class="line">   console.log(&apos;a()&apos;)</span><br><span class="line"> &#125;;</span><br><span class="line"> Function.prototype.b = function()&#123;</span><br><span class="line">   console.log(&apos;b()&apos;)</span><br><span class="line"> &#125;;</span><br><span class="line"> var f = new F();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> f.a()  // a()</span><br><span class="line"> f.b()  // 报错 f.b is not a function</span><br><span class="line"> F.a()  // a()</span><br><span class="line"> F.b()  // b()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/03/hello-world/"/>
      <url>/2019/09/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2019/09/03/git/"/>
      <url>/2019/09/03/git/</url>
      
        <content type="html"><![CDATA[<p>#1. Linux的命令</p><ul><li>mkdir xxx 新建文件夹</li></ul><ul><li>vi x.txt 新建文件（Visual editor）</li></ul><pre><code>- 输入 i 进入编辑模式- ESC + ：+ wq 保存并退出</code></pre><ul><li>cd xxx 进入xxx目录</li></ul><ul><li>cd .. 返回上一级目录</li></ul><ul><li><p>ls 列出当前文件夹中所有文件</p></li><li><p>pwd 显示当前目录</p></li></ul><ul><li>cat x.txt 显示文件内容</li></ul><ul><li><p>clear 清屏</p></li><li><p>！q 强制退出<br>#2.Git指令#<br>##1.基本指令#</p></li><li><p>git config –global user.name “Your Name”     （写用户名）</p></li><li><p>git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“     （写邮箱）</p></li><li><p>git config user.name    （查看配置的姓名）</p></li><li><p>git config user.email    （查看配置的邮箱）</p></li><li><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p></li></ul><p>##2.创建版本库</p><ul><li>git init初始化版本库</li></ul><ul><li>创建成功会提示 Initialized empty Git repository in c:/Users/熊键/Desktop/0725git/.git/</li></ul><ul><li>没有初始化执行git命令，会提示fatal: Not a git repository (or any of the parent directories): .git</li></ul><ul><li>你还会发现目录上多出一个.git的文件夹,这个文件夹是Git来跟踪管理版本库的，不要去修改这个文件里的内容。</li></ul><ul><li>git add x.txt添加指定文件到仓库中</li></ul><ul><li>不会有任何提示，但是提交成功了</li></ul><ul><li>失败会提示fatal: pathspec ‘x.txt’ did not match any files</li></ul><ul><li>可能会出现警告，由于linux和window的换行符不一致导致的。</li></ul><ul><li>警告内容：warning: LF will be replaced by CRLF in a.txt. </li></ul><ul><li>解决方式：git config –global core.autocrlf false </li></ul><ul><li>怎么查看有没有添加成功呢？</li></ul><ul><li>git status 红色表示在工作区，绿色表示在暂存区</li></ul><ul><li>git commit -m ‘xxx’提交所有文件</li></ul><ul><li>提交成功会提示：                                                [master (root-commit) 88bbb64] first commit<br>1 file changed, 2 insertions(+)<br>create mode 100644 x.txt</li></ul><ul><li><p>如果只输入git commit会出问题，ESC + ：+ wq 退出就好</p></li><li><p><strong>在文件在暂存区用Vi修改文件时，此时如果使用git status检查，会红色绿色都有，也就意味着，此时文件在工作区和版权区都存在</strong></p></li></ul><p>##3.理解工作区+版本区+暂存区</p><ul><li>工作区（working Directory）<strong>[在当前目录下，除了.git 的其他区域]</strong>：简单的理解你在电脑里能看到的目录。</li></ul><ul><li>版本库（Repository）<strong>[.git文件]</strong>：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li></ul><ul><li>暂存区（stage）<strong>[.git文件下的index文件]</strong>：Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li></ul><ul><li><strong>第一步是用git add把文件添加进去，实际上就是将工作区文件添加到暂存区</strong></li></ul><ul><li><strong>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支（版本库）</strong></li></ul><p>##4.差异对比</p><ul><li><p>git diff : 比较工作区与暂存区</p></li><li><p>git diff –cached : 比较暂存区与版本区</p></li><li><p>git diff master : 比较工作区与版本区</p></li></ul><p>##5.日志与版本号</p><ul><li><p>git log 显示从最近到最远的所有提交日志</p></li><li><p>git reflog 显示每次提交（commit）的commit id</p></li></ul><p>##6.版本回退+版本穿梭+版本撤销</p><ul><li><p>git reset –hard HEAD^ 版本回退（回退一次提交）</p></li><li><p>git reset –hard Obfafd 回退到指定Obfafd的commit id版本</p></li></ul><ul><li>git reset HEAD 将暂存区的目录树重写为HEAD指向的版本库中的目录树</li></ul><ul><li>git checkout – x.txt 将暂存区指定的文件替换工作区的文件（危险）</li></ul><ul><li>git checkout HEAD x.txt 将HEAD指向的版本库中的文件替换暂存区和工作区的文件（危险）</li></ul><ul><li>git rm –cached x.txt 从暂存区删除文件</li><li><strong>git reset –hard HEAD^  回退到上一个版本</strong></li><li><strong>git reset –hard xxx（commitid） 回退到指定版本</strong></li></ul><p>##7.删除文件</p><ul><li>git rm x.txt 删除文件</li></ul><ul><li>git rm -r x.txt 删除文件夹</li></ul><p>##8.分支</p><ul><li>git checkout -b dev 创建dev分支，并切换到dev分支</li></ul><ul><li>git checkout master 切换分支</li></ul><ul><li>git merge dev 合并指定dev分支到当前分支</li></ul><ul><li>git branch -d dev 删除指定分支</li></ul><ul><li>git branch 查看当前分支</li></ul><ul><li>git diff branch1 branch2 显示出两个分支之间所有有差异的文件的详细差异<strong>（两个分支必须都添加到版本库）</strong></li></ul><ul><li>git diff branch1 branch2 –stat （统计大概）显示出两个分支之间所有有差异的文件列表</li></ul><ul><li>git diff branch1 branch2 文件名(带路径) 显示指定文件的详细差异</li></ul><p>##9.版本冲突（手动解决）</p><p>##10.版本控制工具的区别</p><ul><li>集中式和分布式的区别<ul><li>集中式代码集中存放在中央服务器，其他开发者只有其中的某一个版本。分布式每个开发者都有完整的版本库</li><li>集中式必须联网才能进行版本控制，分布式可以离线开发<br>#3.github</li></ul></li><li>是什么？<ul><li>基于git一个网址，用来托管git项目网址</li></ul></li><li>本地有项目，远程空仓库<ul><li>本地先进行版本控制<ul><li>git init</li><li>git add .</li><li>git commit -m ‘xxx’</li></ul></li><li>本地和远程进行关联<ul><li>git remote add origin xxxxx</li></ul></li><li>将本地项目推送到远程仓库中<ul><li>git push -u origin master 首次</li><li>git push origin master 之后</li></ul></li></ul></li><li>本地没东西，远程有项目<ul><li>将远程仓库中的项目克隆到本地来<ul><li>git clone xxxxx  将远程仓库克隆到本地（将远程和本地关联） </li></ul></li></ul></li><li>本地有修改<ul><li>本地先进行版本控制<ul><li>git init</li><li>git add .</li><li>git commit -m ‘xxx’</li></ul></li><li>将本地项目推送到远程仓库中<ul><li>git push origin master</li></ul></li></ul></li><li>远程有修改<ul><li>git pull origin master 将远程仓库中的内容更新到本地来（直接合并文件,可能导致冲突）</li><li>git fetch origin dev:test 将远程仓库中指定分支dev的内容更新到本地并新建一个分支test保存（不会导致冲突）</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
